<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>サニーさんサバイバー（タッチ対応）</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; }
    body {
      margin: 0; padding: 0; background: #1a1a2e; color:#fff;
      font-family: monospace; overflow: hidden;
    }
    #gameContainer {
      position: relative; width: 100vw; height: 100vh;
      border: 3px solid #4a4a8a; border-radius: 10px; box-sizing: border-box;
    }
    canvas { display:block; width:100%; height:100%; background:#16213e; border-radius:7px; touch-action:none; }
    #ui {
      position:absolute; top:10px; left:10px; z-index:10;
      background:rgba(0,0,0,.6); padding:8px 10px; border-radius:6px; font-size:14px;
    }
    #levelUpModal {
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      background:rgba(0,0,0,.9); border:2px solid #ffd700; border-radius:10px;
      padding:20px; display:none; z-index:100; width:min(90vw,320px);
    }
    .upgrade-btn {
      display:block; width:100%; margin:6px 0; padding:10px;
      background:#4a4a8a; border:none; color:#fff; border-radius:6px; cursor:pointer;
      font-family:monospace; font-size:14px;
    }
    .upgrade-btn:hover { background:#6a6aaa; }
    #controls {
      position:absolute; bottom:8px; left:50%; transform:translateX(-50%);
      font-size:12px; color:#aaa; text-align:center; background:rgba(0,0,0,.35);
      padding:6px 10px; border-radius:6px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
      <div>HP: <span id="hp">100</span>/100</div>
      <div>Level: <span id="level">1</span></div>
      <div>EXP: <span id="exp">0</span>/<span id="expMax">10</span></div>
      <div>Score: <span id="score">0</span></div>
      <div>Time: <span id="time">0</span>s</div>
      <div>武器: <span id="weapon">速射Lv1</span></div>
    </div>

    <div id="levelUpModal">
      <h3>レベルアップ！</h3>
      <button class="upgrade-btn" onclick="selectUpgrade('weapon')">武器強化</button>
      <button class="upgrade-btn" onclick="selectUpgrade('weapon_change')">武器変更</button>
      <button class="upgrade-btn" onclick="selectUpgrade('speed')">移動速度アップ</button>
      <button class="upgrade-btn" onclick="selectUpgrade('health')">最大HP +20</button>
    </div>

    <div id="controls">
      スマホ: タッチ＝移動 / 攻撃は完全オート<br/>
      PC: WASD/矢印=移動 / 攻撃は完全オート / R=リスタート
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ===== レスポンシブ（画面いっぱい） =====
    function resizeCanvas(){
      const dpr = window.devicePixelRatio || 1;
      const cssW = document.documentElement.clientWidth;
      const cssH = document.documentElement.clientHeight;
      // デバイスピクセルに合わせて内部サイズ確保
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.width  = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
      // 描画座標系をCSSピクセルに合わせる
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      // 端制限のため、プレイヤーの位置を補正
      if (gameState.player){
        const r = gameState.player.size || 16;
        gameState.player.x = Math.max(r, Math.min(cssW - r, gameState.player.x));
        gameState.player.y = Math.max(r, Math.min(cssH - r, gameState.player.y));
      }
    }
    window.addEventListener('resize', resizeCanvas);

    // ===== 画像 =====
    const characterImages = { normal:null, orbs:null, damaged:null };
    function loadImage(src){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; }); }
    async function loadCharacterImages(){
      try{
        const [n,o,d]=await Promise.all([loadImage('image1.png'),loadImage('image2.png'),loadImage('image3.png')]);
        characterImages.normal=n; characterImages.orbs=o; characterImages.damaged=d; return true;
      }catch(e){ console.warn('画像読み込み失敗',e); return false;}
    }

    // ===== 入力（キーボード + タッチ） =====
    const inputState = {
      keys: {},
      // タッチ移動（画面のどこでも可能）
      move: { id:null, startX:0, startY:0, x:0, y:0, active:false },
      dead: 10, // デッドゾーン(px)
    };

    document.addEventListener('keydown', e => {
      inputState.keys[e.key.toLowerCase()] = true;
      if (e.key.toLowerCase() === 'r' && gameState.player && gameState.player.hp<=0) initGame();
    });
    document.addEventListener('keyup', e => { inputState.keys[e.key.toLowerCase()] = false; });

    // タッチ→キャンバス座標
    function toCanvasPos(t){
      const rect = canvas.getBoundingClientRect();
      return { x: t.clientX - rect.left, y: t.clientY - rect.top };
    }

    function handleTouchStart(e){
      e.preventDefault();
      // 複数タッチの場合は最初のタッチのみ使用
      if (!inputState.move.active && e.changedTouches.length > 0) {
        const t = e.changedTouches[0];
        const p = toCanvasPos(t);
        inputState.move = { id:t.identifier, startX:p.x, startY:p.y, x:p.x, y:p.y, active:true };
      }
    }
    
    function handleTouchMove(e){
      e.preventDefault();
      for (const t of e.changedTouches){
        if (inputState.move.active && t.identifier === inputState.move.id){
          const p = toCanvasPos(t);
          inputState.move.x = p.x; 
          inputState.move.y = p.y;
        }
      }
    }
    
    function handleTouchEnd(e){
      e.preventDefault();
      for (const t of e.changedTouches){
        if (inputState.move.active && t.identifier === inputState.move.id){
          inputState.move.active = false; 
          inputState.move.id = null;
        }
      }
    }
    
    canvas.addEventListener('touchstart', handleTouchStart, {passive:false});
    canvas.addEventListener('touchmove',  handleTouchMove,  {passive:false});
    canvas.addEventListener('touchend',   handleTouchEnd,   {passive:false});
    canvas.addEventListener('touchcancel',handleTouchEnd,   {passive:false});

    // ベクトル取得（移動）
    function getMoveVector(speed){
      // キー優先（PC用）
      let dx=0, dy=0;
      if (inputState.keys['w']||inputState.keys['arrowup'])    dy -= 1;
      if (inputState.keys['s']||inputState.keys['arrowdown'])  dy += 1;
      if (inputState.keys['a']||inputState.keys['arrowleft'])  dx -= 1;
      if (inputState.keys['d']||inputState.keys['arrowright']) dx += 1;

      // タッチ（画面全体）
      if (dx===0 && dy===0 && inputState.move.active){
        const vx = inputState.move.x - inputState.move.startX;
        const vy = inputState.move.y - inputState.move.startY;
        const len = Math.hypot(vx,vy);
        if (len > inputState.dead){
          dx = vx/len; dy = vy/len;
        }
      }
      // 正規化
      if (dx!==0 && dy!==0){ dx *= 0.7071; dy *= 0.7071; }
      return {dx: dx*speed, dy: dy*speed, moving: (dx!==0 || dy!==0)};
    }

    // 完全オートエイム（最も近い敵を狙う）
    function getAutoAimAngle(player){
      let target=null, best=Infinity;
      for(const e of gameState.enemies){
        const d=Math.hypot(e.x-player.x, e.y-player.y);
        if (d<best){ best=d; target=e; }
      }
      if (target) return Math.atan2(target.y-player.y, target.x-player.x);
      return null;
    }

    // ===== 難易度ディレクター（10分クリア想定） =====
    function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
    function lerp(a,b,t){ return a + (b-a)*clamp(t,0,1); }
    function getDifficulty(frames){
      const sec = frames/60, min=sec/60, t=clamp(min/10,0,1);
      const spawnInterval = Math.round(lerp(110, 50, t));   // 1.83s → 0.83s
      const batchSize     = 1 + Math.floor(lerp(0, 6, t));  // 1 → 7
      const maxEnemies    = Math.floor(lerp(30, 90, t));    // 30 → 90
      const enemyHP  = Math.round(lerp(22, 100, t));
      const enemySpd = lerp(1.0, 2.2, t);
      const enemyDmg = Math.round(lerp(12, 22, t));
      const expValue = 2 + Math.floor(lerp(0, 3, t));       // 2 → 5
      const baseFireRate = Math.round(lerp(800, 320, t));   // 0.8s → 0.32s
      const baseDamage   = Math.round(lerp(22, 36, t));     // 22 → 36
      return {sec,min,t,spawnInterval,batchSize,maxEnemies,enemyHP,enemySpd,enemyDmg,expValue,baseFireRate,baseDamage};
    }

    // ===== ゲーム状態 =====
    let gameState = {
      player:null, enemies:[], bullets:[], particles:[], items:[],
      gameTime:0, lastEnemySpawn:0, isPaused:false
    };

    // ===== 武器システム定数 =====
    const WeaponType = {
      SPEED: 'speed',    // 速射型
      SPREAD: 'spread',  // 弾幕型  
      LASER: 'laser'     // レーザー型
    };

    // ===== クラス =====
    class Player{
      constructor(x,y){
        this.x=x; this.y=y;
        this.imageScale=0.8;                 // 指定どおり
        this.size=32*this.imageScale;        // 画像読込後に再計算：当たり判定半径
        this.speed=3;
        this.maxHp=100; this.hp=this.maxHp;
        this.level=1; this.exp=0; this.expMax=10; this.score=0;
        this.lastShot=0;
        this.fireRate=800;                   // 初期遅い（ディレクターで自然短縮）
        this.damage=22;                      // 同上
        this.invulnerable=0;
        this.orbRotation=0;
        this.isMoving=false;
        this.weapon = new WeaponSystem();    // 武器システム追加
      }
      updateCollisionSizeFromImage(){
        if (characterImages.normal){
          this.size = (characterImages.normal.width * this.imageScale) / 2;
        }
      }
      update(){
        const diff = getDifficulty(gameState.gameTime);
        // 自然成長（レベルとは別）
        this.fireRate = Math.min(this.fireRate, diff.baseFireRate);
        this.damage   = Math.max(this.damage, diff.baseDamage);

        const mv = getMoveVector(this.speed);
        this.isMoving = mv.moving;
        // 端まで行ける（中心が半径分だけ内側）
        const r=this.size, W=canvas.clientWidth, H=canvas.clientHeight;
        this.x = Math.max(r, Math.min(W - r, this.x + mv.dx));
        this.y = Math.max(r, Math.min(H - r, this.y + mv.dy));

        if (this.isMoving) this.orbRotation += 0.1;
        if (this.invulnerable>0) this.invulnerable--;

        // 武器システムを使った攻撃
        const currentFireRate = this.weapon.getFireRate(this.fireRate);
        if (Date.now() - this.lastShot > currentFireRate && gameState.enemies.length>0){
          this.shoot(); this.lastShot=Date.now();
        }
      }
      shoot(){
        const ang = getAutoAimAngle(this);
        if (ang==null) return;
        
        // 武器システムから弾を生成
        const bullets = this.weapon.getShootPattern(this.x, this.y, ang, this.damage);
        bullets.forEach(bullet => gameState.bullets.push(bullet));
      }
      takeDamage(d){ 
        if(this.invulnerable>0) return; 
        this.hp=Math.max(0,this.hp-d); 
        this.invulnerable=60; 
        for(let i=0;i<5;i++) gameState.particles.push(new Particle(this.x,this.y,'#f00')); 
      }
      gainExp(v){ 
        this.exp+=v; 
        this.score+=v*10; 
        if(this.exp>=this.expMax) this.levelUp(); 
      }
      levelUp(){ 
        this.level++; 
        this.exp-=this.expMax; 
        this.expMax=Math.floor(this.expMax*1.5); 
        document.getElementById('levelUpModal').style.display='block'; 
        gameState.isPaused=true; 
      }
      draw(){
        ctx.save();
        let damaged=false;
        if (this.invulnerable>0){ 
          if(Math.floor(this.invulnerable/10)%2===0) damaged=true; 
          ctx.globalAlpha=0.8; 
        }

        if (characterImages.normal && characterImages.orbs && characterImages.damaged){
          // オーブ常時表示（移動中のみ回転角が進む）
          ctx.save(); 
          ctx.translate(this.x,this.y); 
          ctx.rotate(this.orbRotation);
          const os = characterImages.orbs.width * this.imageScale;
          ctx.drawImage(characterImages.orbs, -os/2, -os/2, os, os); 
          ctx.restore();

          const img = damaged ? characterImages.damaged : characterImages.normal;
          const isz = img.width * this.imageScale;
          ctx.drawImage(img, this.x - isz/2, this.y - isz/2, isz, isz);
        } else {
          // フォールバック
          ctx.fillStyle = damaged ? '#ffaa00' : '#ffcc00';
          ctx.beginPath(); 
          ctx.arc(this.x,this.y,this.size,0,Math.PI*2); 
          ctx.fill();
          ctx.strokeStyle='#000'; 
          ctx.lineWidth=2; 
          ctx.stroke();
          ctx.fillStyle='#000'; 
          ctx.font=`${this.size}px Arial`; 
          ctx.textAlign='center'; 
          ctx.textBaseline='middle';
          ctx.fillText(damaged?'😞':'😊', this.x, this.y);
        }
        
        // HPバー
        const barW=40, barH=4, barY=this.y - (this.size+15);
        ctx.fillStyle='#f00'; 
        ctx.fillRect(this.x-barW/2,barY,barW,barH);
        ctx.fillStyle='#0f0'; 
        ctx.fillRect(this.x-barW/2,barY,barW*(this.hp/this.maxHp),barH);
        ctx.strokeStyle='#fff'; 
        ctx.lineWidth=1; 
        ctx.strokeRect(this.x-barW/2,barY,barW,barH);
        ctx.restore();

        // タッチUIの円（簡易スティック表示）
        drawTouchUI();
      }
    }

    class Enemy{
      constructor(x,y,diff){
        this.x=x; this.y=y;
        this.size=16;
        this.speed=diff.enemySpd;
        this.hp=diff.enemyHP; this.maxHp=this.hp;
        this.damage=diff.enemyDmg;
        this.expValue=diff.expValue;
        this.color=`hsl(${Math.random()*60+300},70%,50%)`;
      }
      update(){
        const dx=gameState.player.x-this.x, dy=gameState.player.y-this.y;
        const dist=Math.hypot(dx,dy);
        if (dist>0){ 
          this.x+=(dx/dist)*this.speed; 
          this.y+=(dy/dist)*this.speed; 
        }
        if (dist < this.size + gameState.player.size){ 
          gameState.player.takeDamage(this.damage); 
        }
      }
      takeDamage(d){
        this.hp -= d;
        for(let i=0;i<3;i++) gameState.particles.push(new Particle(this.x,this.y,this.color));
        if(this.hp<=0){ 
          gameState.items.push(new ExpItem(this.x,this.y,this.expValue)); 
          return true; 
        }
        return false;
      }
      draw(){
        ctx.fillStyle=this.color; 
        ctx.beginPath(); 
        ctx.arc(this.x,this.y,this.size,0,Math.PI*2); 
        ctx.fill();
        ctx.fillStyle='#fff'; 
        ctx.beginPath(); 
        ctx.arc(this.x-4,this.y-4,2,0,Math.PI*2); 
        ctx.arc(this.x+4,this.y-4,2,0,Math.PI*2); 
        ctx.fill();
        ctx.fillStyle='#000'; 
        ctx.beginPath(); 
        ctx.arc(this.x-4,this.y-4,1,0,Math.PI*2); 
        ctx.arc(this.x+4,this.y-4,1,0,Math.PI*2); 
        ctx.fill();
        
        if(this.hp<this.maxHp){
          const w=20,h=3; 
          ctx.fillStyle='#f00'; 
          ctx.fillRect(this.x-w/2,this.y-this.size-8,w,h);
          ctx.fillStyle='#0f0'; 
          ctx.fillRect(this.x-w/2,this.y-this.size-8,w*(this.hp/this.maxHp),h);
        }
      }
    }

    class Bullet{
      constructor(x,y,ang,damage,isPlayerBullet=false){
        this.x=x; this.y=y; 
        this.vx=Math.cos(ang)*8; 
        this.vy=Math.sin(ang)*8;
        this.damage=damage; 
        this.isPlayerBullet=isPlayerBullet; 
        this.life=120;
      }
      update(){
        this.x+=this.vx; 
        this.y+=this.vy; 
        this.life--;
        const W=canvas.clientWidth, H=canvas.clientHeight;
        if(this.x<0||this.x>W||this.y<0||this.y>H||this.life<=0) return true;
        
        if(this.isPlayerBullet){
          for(let i=gameState.enemies.length-1;i>=0;i--){
            const e=gameState.enemies[i];
            const d=Math.hypot(e.x-this.x,e.y-this.y);
            if(d<e.size){
              if(e.takeDamage(this.damage)) gameState.enemies.splice(i,1);
              return true;
            }
          }
        }
        return false;
      }
      draw(){
        ctx.fillStyle=this.isPlayerBullet?'#ff0':'#f00';
        ctx.beginPath(); 
        ctx.arc(this.x,this.y,3,0,Math.PI*2); 
        ctx.fill();
        ctx.fillStyle=this.isPlayerBullet?'rgba(255,255,0,.3)':'rgba(255,0,0,.3)';
        ctx.beginPath(); 
        ctx.arc(this.x-this.vx,this.y-this.vy,2,0,Math.PI*2); 
        ctx.fill();
      }
    }

    // ===== レーザー弾クラス =====
    class LaserBullet extends Bullet {
      constructor(x, y, angle, damage, isPlayerBullet, speed = 10, pierce = false, reflect = false) {
        super(x, y, angle, damage, isPlayerBullet);
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.pierce = pierce;
        this.reflect = reflect;
        this.hitTargets = new Set(); // 貫通時の重複ヒット防止
        this.life = 180; // レーザーは長寿命
        this.reflectCount = 0;
        this.maxReflects = 3;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        
        const W = canvas.clientWidth, H = canvas.clientHeight;
        
        // 反射処理
        if (this.reflect && this.reflectCount < this.maxReflects) {
          if (this.x <= 0 || this.x >= W) {
            this.vx *= -1;
            this.x = Math.max(0, Math.min(W, this.x));
            this.reflectCount++;
          }
          if (this.y <= 0 || this.y >= H) {
            this.vy *= -1;
            this.y = Math.max(0, Math.min(H, this.y));
            this.reflectCount++;
          }
        } else {
          // 通常の境界チェック
          if (this.x < 0 || this.x > W || this.y < 0 || this.y > H || this.life <= 0) {
            return true;
          }
        }

        // 敵との当たり判定
        if (this.isPlayerBullet) {
          for (let i = gameState.enemies.length - 1; i >= 0; i--) {
            const e = gameState.enemies[i];
            const d = Math.hypot(e.x - this.x, e.y - this.y);
            
            if (d < e.size && !this.hitTargets.has(e)) {
              if (this.pierce) {
                this.hitTargets.add(e);
              }
              
              if (e.takeDamage(this.damage)) {
                gameState.enemies.splice(i, 1);
              }
              
              if (!this.pierce) {
                return true; // 貫通しない場合は消滅
              }
            }
          }
        }
        
        return false;
      }

      draw() {
        ctx.save();
        // レーザーらしい描画
        const angle = Math.atan2(this.vy, this.vx);
        const length = Math.hypot(this.vx, this.vy) * 2;
        
        ctx.translate(this.x, this.y);
        ctx.rotate(angle);
        
        // コア部分（明るい）
        ctx.fillStyle = this.isPlayerBullet ? '#ff00ff' : '#ff0000';
        ctx.fillRect(-length/2, -2, length, 4);
        
        // 外側（薄い）
        ctx.fillStyle = this.isPlayerBullet ? 'rgba(255,0,255,0.3)' : 'rgba(255,0,0,0.3)';
        ctx.fillRect(-length/2, -4, length, 8);
        
        ctx.restore();
      }
    }

    // ===== 武器システム =====
    class WeaponSystem {
      constructor() {
        this.type = WeaponType.SPEED; // 初期武器
        this.level = 1;
        this.maxLevel = 5;
      }

      // 武器レベルアップ
      levelUp() {
        if (this.level < this.maxLevel) {
          this.level++;
          return true;
        }
        return false;
      }

      // 武器切り替え（レベル引き継ぎ）
      switchWeapon(newType) {
        this.type = newType;
        // レベルは維持される
      }

      // 射撃パターンを取得
      getShootPattern(x, y, angle, damage) {
        switch(this.type) {
          case WeaponType.SPEED:
            return this.getSpeedPattern(x, y, angle, damage);
          case WeaponType.SPREAD:
            return this.getSpreadPattern(x, y, angle, damage);
          case WeaponType.LASER:
            return this.getLaserPattern(x, y, angle, damage);
          default:
            return [];
        }
      }

      // 速射型パターン
      getSpeedPattern(x, y, angle, damage) {
        const bullets = [];
        if (this.level >= 3) {
          // Lv3: 2連射
          const offset = 0.1;
          bullets.push(new Bullet(x, y, angle - offset, damage, true));
          bullets.push(new Bullet(x, y, angle + offset, damage, true));
        }
        if (this.level >= 5) {
          // Lv5: 3連射（中央追加）
          bullets.push(new Bullet(x, y, angle, damage, true));
        }
        if (bullets.length === 0) {
          // Lv1-2: 単発
          bullets.push(new Bullet(x, y, angle, damage, true));
        }
        return bullets;
      }

      // 弾幕型パターン  
      getSpreadPattern(x, y, angle, damage) {
        const bullets = [];
        if (this.level >= 5) {
          // Lv5: 7-9way大弾幕
          const ways = 9;
          const spread = Math.PI / 3; // 60度範囲
          for (let i = 0; i < ways; i++) {
            const a = angle - spread/2 + (spread / (ways-1)) * i;
            bullets.push(new Bullet(x, y, a, damage * 0.8, true)); // 威力少し下げる
          }
        } else if (this.level >= 3) {
          // Lv3: 拡散＋中央直進弾
          bullets.push(new Bullet(x, y, angle, damage, true)); // 中央
          const ways = 5;
          const spread = Math.PI / 4; // 45度範囲
          for (let i = 0; i < ways; i++) {
            const a = angle - spread/2 + (spread / (ways-1)) * i;
            bullets.push(new Bullet(x, y, a, damage * 0.7, true));
          }
        } else {
          // Lv1-2: 3way
          bullets.push(new Bullet(x, y, angle - 0.3, damage * 0.8, true));
          bullets.push(new Bullet(x, y, angle, damage, true));
          bullets.push(new Bullet(x, y, angle + 0.3, damage * 0.8, true));
        }
        return bullets;
      }

      // レーザー型パターン
      getLaserPattern(x, y, angle, damage) {
        const bullets = [];
        const speed = this.level >= 3 ? 12 : 10; // Lv3+で高速
        const pierce = this.level >= 3; // Lv3+で貫通
        const reflect = this.level >= 5; // Lv5で反射
        
        const bullet = new LaserBullet(x, y, angle, damage * 1.5, true, speed, pierce, reflect);
        bullets.push(bullet);
        return bullets;
      }

      // 連射速度取得
      getFireRate(baseRate) {
        switch(this.type) {
          case WeaponType.SPEED:
            // 速射型は連射速度最優先
            return Math.max(100, baseRate - (this.level * 80));
          case WeaponType.SPREAD:
            // 弾幕型は標準的な連射速度
            return Math.max(200, baseRate - (this.level * 40));
          case WeaponType.LASER:
            // レーザー型は低連射だが高威力
            return Math.max(400, baseRate - (this.level * 20));
          default:
            return baseRate;
        }
      }

      // 武器名取得
      getWeaponName() {
        const names = {
          [WeaponType.SPEED]: '速射',
          [WeaponType.SPREAD]: '弾幕', 
          [WeaponType.LASER]: 'レーザー'
        };
        return `${names[this.type]}Lv${this.level}`;
      }
    }

    class Particle{
      constructor(x,y,color){ 
        this.x=x; this.y=y; 
        this.vx=(Math.random()-0.5)*4; 
        this.vy=(Math.random()-0.5)*4; 
        this.color=color; 
        this.life=30; 
        this.maxLife=30; 
        this.size=Math.random()*3+1; 
      }
      update(){ 
        this.x+=this.vx; 
        this.y+=this.vy; 
        this.vx*=0.98; 
        this.vy*=0.98; 
        this.life--; 
        return this.life<=0; 
      }
      draw(){ 
        const a=this.life/this.maxLife; 
        ctx.save(); 
        ctx.globalAlpha=a; 
        ctx.fillStyle=this.color; 
        ctx.beginPath(); 
        ctx.arc(this.x,this.y,this.size,0,Math.PI*2); 
        ctx.fill(); 
        ctx.restore(); 
      }
    }
    
    class ExpItem{
      constructor(x,y,v){ 
        this.x=x; this.y=y; 
        this.value=v; 
        this.size=4; 
        this.bobOffset=Math.random()*Math.PI*2; 
      }
      update(){
        const dx=gameState.player.x-this.x, dy=gameState.player.y-this.y, dist=Math.hypot(dx,dy);
        if(dist<50){ 
          this.x+=(dx/dist)*3; 
          this.y+=(dy/dist)*3; 
        }
        if(dist < this.size + gameState.player.size){ 
          gameState.player.gainExp(this.value); 
          return true; 
        }
        return false;
      }
      draw(){
        const bob=Math.sin(Date.now()*0.005 + this.bobOffset)*2;
        ctx.fillStyle='#0f0'; 
        ctx.beginPath(); 
        ctx.arc(this.x,this.y+bob,this.size,0,Math.PI*2); 
        ctx.fill();
        ctx.strokeStyle='#fff'; 
        ctx.lineWidth=1; 
        ctx.stroke();
      }
    }

    // タッチUI（円を描くだけ）
    function drawTouchUI(){
      if (inputState.move.active) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#00ffff';
        // 外側の円（タッチ開始位置）
        ctx.beginPath(); 
        ctx.arc(inputState.move.startX, inputState.move.startY, 40, 0, Math.PI*2); 
        ctx.stroke();
        // 内側の円（現在位置）
        ctx.beginPath(); 
        ctx.arc(inputState.move.x, inputState.move.y, 20, 0, Math.PI*2); 
        ctx.stroke();
        // 線で結ぶ
        ctx.beginPath();
        ctx.moveTo(inputState.move.startX, inputState.move.startY);
        ctx.lineTo(inputState.move.x, inputState.move.y);
        ctx.stroke();
        ctx.restore();
      }
    }

    // ===== スポーン =====
    function spawnEnemy(){
      const diff = getDifficulty(gameState.gameTime);
      if (gameState.enemies.length >= diff.maxEnemies) return;
      const W=canvas.clientWidth, H=canvas.clientHeight;
      const side=Math.floor(Math.random()*4);
      let x,y;
      if(side===0){ x=Math.random()*W; y=-20; }
      else if(side===1){ x=W+20; y=Math.random()*H; }
      else if(side===2){ x=Math.random()*W; y=H+20; }
      else { x=-20; y=Math.random()*H; }
      gameState.enemies.push(new Enemy(x,y,diff));
    }

    // ===== アップグレード =====
    function selectUpgrade(type){
      const p=gameState.player;
      if (type==='weapon') {
        // 武器レベルアップ
        p.weapon.levelUp();
      } else if (type==='weapon_change') {
        // 武器タイプ変更（サイクル）
        const types = [WeaponType.SPEED, WeaponType.SPREAD, WeaponType.LASER];
        const currentIndex = types.indexOf(p.weapon.type);
        const nextIndex = (currentIndex + 1) % types.length;
        p.weapon.switchWeapon(types[nextIndex]);
      } else if (type==='speed') {
        p.speed+=0.5;
      } else if (type==='health') { 
        p.maxHp+=20; 
        p.hp=Math.min(p.hp+20,p.maxHp); 
      }
      document.getElementById('levelUpModal').style.display='none';
      gameState.isPaused=false;
    }
    window.selectUpgrade = selectUpgrade;

    // ===== UI =====
    function updateUI(){
      const p=gameState.player;
      document.getElementById('hp').textContent=p.hp; 
      document.getElementById('level').textContent=p.level; 
      document.getElementById('exp').textContent=p.exp;
      document.getElementById('expMax').textContent=p.expMax; 
      document.getElementById('score').textContent=p.score;
      document.getElementById('time').textContent=Math.floor(gameState.gameTime/60);
      document.getElementById('weapon').textContent=p.weapon.getWeaponName();
    }

    // ===== ループ =====
    function gameLoop(){
      if (!gameState.isPaused){
        gameState.gameTime++;
        const diff = getDifficulty(gameState.gameTime);
        const since = gameState.gameTime - gameState.lastEnemySpawn;
        if (since > diff.spawnInterval){
          for(let i=0;i<diff.batchSize;i++) spawnEnemy();
          gameState.lastEnemySpawn = gameState.gameTime;
        }
        if (gameState.player.hp>0) gameState.player.update();
        gameState.enemies.forEach(e=>e.update());
        gameState.bullets   = gameState.bullets.filter(b=>!b.update());
        gameState.particles = gameState.particles.filter(p=>!p.update());
        gameState.items     = gameState.items.filter(it=>!it.update());
        updateUI();
      }

      // 背景
      const W=canvas.clientWidth, H=canvas.clientHeight;
      ctx.fillStyle='#16213e'; 
      ctx.fillRect(0,0,W,H);
      ctx.strokeStyle='rgba(255,255,255,0.05)'; 
      ctx.lineWidth=1;
      for(let x=0;x<W;x+=50){ 
        ctx.beginPath(); 
        ctx.moveTo(x,0); 
        ctx.lineTo(x,H); 
        ctx.stroke(); 
      }
      for(let y=0;y<H;y+=50){ 
        ctx.beginPath(); 
        ctx.moveTo(0,y); 
        ctx.lineTo(W,y); 
        ctx.stroke(); 
      }

      gameState.items.forEach(it=>it.draw());
      gameState.particles.forEach(p=>p.draw());
      gameState.enemies.forEach(e=>e.draw());
      gameState.bullets.forEach(b=>b.draw());

      if (gameState.player.hp>0) gameState.player.draw();
      
      if (gameState.player.hp<=0){
        ctx.fillStyle='rgba(0,0,0,.7)'; 
        ctx.fillRect(0,0,W,H);
        ctx.fillStyle='#fff'; 
        ctx.font='48px monospace'; 
        ctx.textAlign='center';
        ctx.fillText('GAME OVER', W/2, H/2);
        ctx.font='24px monospace';
        ctx.fillText(`Final Score: ${gameState.player.score}`, W/2, H/2+50);
        ctx.fillText('Press R to Restart', W/2, H/2+100);
      }

      requestAnimationFrame(gameLoop);
    }

    // ===== 初期化 =====
    async function initGame(){
      await loadCharacterImages();
      resizeCanvas();
      gameState.player = new Player(canvas.clientWidth/2, canvas.clientHeight/2);
      gameState.player.updateCollisionSizeFromImage();
      gameState.enemies=[]; gameState.bullets=[]; gameState.particles=[]; gameState.items=[];
      gameState.gameTime=0; gameState.lastEnemySpawn=0; gameState.isPaused=false;
      document.getElementById('levelUpModal').style.display='none';
    }

    initGame().then(()=>{ gameLoop(); });
  </script>
</body>
</html>
