<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>ã‚µãƒ‹ãƒ¼ã•ã‚“ã‚µãƒã‚¤ãƒãƒ¼ï¼ˆã‚¿ãƒƒãƒå¯¾å¿œï¼‰</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; }
    body {
      margin: 0; padding: 0; background: #1a1a2e; color:#fff;
      font-family: monospace; overflow: hidden;
    }
    #gameContainer {
      position: relative; width: 100vw; height: 100vh;
      border: 3px solid #4a4a8a; border-radius: 10px; box-sizing: border-box;
    }
    canvas { display:block; width:100%; height:100%; background:#16213e; border-radius:7px; touch-action:none; }
    #ui {
      position:absolute; top:10px; left:10px; z-index:10;
      background:rgba(0,0,0,.6); padding:8px 10px; border-radius:6px; font-size:14px;
    }
    #levelUpModal {
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      background:rgba(0,0,0,.9); border:2px solid #ffd700; border-radius:10px;
      padding:20px; display:none; z-index:100; width:min(90vw,320px);
    }
    .upgrade-btn {
      display:block; width:100%; margin:6px 0; padding:10px;
      background:#4a4a8a; border:none; color:#fff; border-radius:6px; cursor:pointer;
      font-family:monospace; font-size:14px;
    }
    .upgrade-btn:hover { background:#6a6aaa; }
    #controls {
      position:absolute; bottom:8px; left:50%; transform:translateX(-50%);
      font-size:12px; color:#aaa; text-align:center; background:rgba(0,0,0,.35);
      padding:6px 10px; border-radius:6px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
      <div>HP: <span id="hp">100</span>/100</div>
      <div>Level: <span id="level">1</span></div>
      <div>EXP: <span id="exp">0</span>/<span id="expMax">10</span></div>
      <div>Score: <span id="score">0</span></div>
      <div>Time: <span id="time">0</span>s</div>
      <div>æ­¦å™¨: <span id="weapon">é€Ÿå°„Lv1</span></div>
    </div>

    <div id="levelUpModal">
      <h3>ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼</h3>
      <button class="upgrade-btn" onclick="selectUpgrade('weapon')">æ­¦å™¨å¼·åŒ–</button>
      <button class="upgrade-btn" onclick="selectUpgrade('weapon_change')">æ­¦å™¨å¤‰æ›´</button>
      <button class="upgrade-btn" onclick="selectUpgrade('speed')">ç§»å‹•é€Ÿåº¦ã‚¢ãƒƒãƒ—</button>
      <button class="upgrade-btn" onclick="selectUpgrade('health')">æœ€å¤§HP +20</button>
    </div>

    <div id="controls">
      ã‚¹ãƒãƒ›: ã‚¿ãƒƒãƒï¼ç§»å‹• / æ”»æ’ƒã¯å®Œå…¨ã‚ªãƒ¼ãƒˆ<br/>
      PC: WASD/çŸ¢å°=ç§»å‹• / æ”»æ’ƒã¯å®Œå…¨ã‚ªãƒ¼ãƒˆ / R=ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ===== ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ï¼ˆç”»é¢ã„ã£ã±ã„ï¼‰ =====
    function resizeCanvas(){
      const dpr = window.devicePixelRatio || 1;
      const cssW = document.documentElement.clientWidth;
      const cssH = document.documentElement.clientHeight;
      // ãƒ‡ãƒã‚¤ã‚¹ãƒ”ã‚¯ã‚»ãƒ«ã«åˆã‚ã›ã¦å†…éƒ¨ã‚µã‚¤ã‚ºç¢ºä¿
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.width  = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
      // æç”»åº§æ¨™ç³»ã‚’CSSãƒ”ã‚¯ã‚»ãƒ«ã«åˆã‚ã›ã‚‹
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      // ç«¯åˆ¶é™ã®ãŸã‚ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’è£œæ­£
      if (gameState.player){
        const r = gameState.player.size || 16;
        gameState.player.x = Math.max(r, Math.min(cssW - r, gameState.player.x));
        gameState.player.y = Math.max(r, Math.min(cssH - r, gameState.player.y));
      }
    }
    window.addEventListener('resize', resizeCanvas);

    // ===== ç”»åƒ =====
    const characterImages = { normal:null, orbs:null, damaged:null };
    function loadImage(src){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; }); }
    async function loadCharacterImages(){
      try{
        const [n,o,d]=await Promise.all([loadImage('image1.png'),loadImage('image2.png'),loadImage('image3.png')]);
        characterImages.normal=n; characterImages.orbs=o; characterImages.damaged=d; return true;
      }catch(e){ console.warn('ç”»åƒèª­ã¿è¾¼ã¿å¤±æ•—',e); return false;}
    }

    // ===== å…¥åŠ›ï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ + ã‚¿ãƒƒãƒï¼‰ =====
    const inputState = {
      keys: {},
      // ã‚¿ãƒƒãƒç§»å‹•ï¼ˆç”»é¢ã®ã©ã“ã§ã‚‚å¯èƒ½ï¼‰
      move: { id:null, startX:0, startY:0, x:0, y:0, active:false },
      dead: 10, // ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³(px)
    };

    document.addEventListener('keydown', e => {
      inputState.keys[e.key.toLowerCase()] = true;
      if (e.key.toLowerCase() === 'r' && gameState.player && gameState.player.hp<=0) initGame();
    });
    document.addEventListener('keyup', e => { inputState.keys[e.key.toLowerCase()] = false; });

    // ã‚¿ãƒƒãƒâ†’ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™
    function toCanvasPos(t){
      const rect = canvas.getBoundingClientRect();
      return { x: t.clientX - rect.left, y: t.clientY - rect.top };
    }

    function handleTouchStart(e){
      e.preventDefault();
      // è¤‡æ•°ã‚¿ãƒƒãƒã®å ´åˆã¯æœ€åˆã®ã‚¿ãƒƒãƒã®ã¿ä½¿ç”¨
      if (!inputState.move.active && e.changedTouches.length > 0) {
        const t = e.changedTouches[0];
        const p = toCanvasPos(t);
        inputState.move = { id:t.identifier, startX:p.x, startY:p.y, x:p.x, y:p.y, active:true };
      }
    }
    
    function handleTouchMove(e){
      e.preventDefault();
      for (const t of e.changedTouches){
        if (inputState.move.active && t.identifier === inputState.move.id){
          const p = toCanvasPos(t);
          inputState.move.x = p.x; 
          inputState.move.y = p.y;
        }
      }
    }
    
    function handleTouchEnd(e){
      e.preventDefault();
      for (const t of e.changedTouches){
        if (inputState.move.active && t.identifier === inputState.move.id){
          inputState.move.active = false; 
          inputState.move.id = null;
        }
      }
    }
    
    canvas.addEventListener('touchstart', handleTouchStart, {passive:false});
    canvas.addEventListener('touchmove',  handleTouchMove,  {passive:false});
    canvas.addEventListener('touchend',   handleTouchEnd,   {passive:false});
    canvas.addEventListener('touchcancel',handleTouchEnd,   {passive:false});

    // ãƒ™ã‚¯ãƒˆãƒ«å–å¾—ï¼ˆç§»å‹•ï¼‰
    function getMoveVector(speed){
      // ã‚­ãƒ¼å„ªå…ˆï¼ˆPCç”¨ï¼‰
      let dx=0, dy=0;
      if (inputState.keys['w']||inputState.keys['arrowup'])    dy -= 1;
      if (inputState.keys['s']||inputState.keys['arrowdown'])  dy += 1;
      if (inputState.keys['a']||inputState.keys['arrowleft'])  dx -= 1;
      if (inputState.keys['d']||inputState.keys['arrowright']) dx += 1;

      // ã‚¿ãƒƒãƒï¼ˆç”»é¢å…¨ä½“ï¼‰
      if (dx===0 && dy===0 && inputState.move.active){
        const vx = inputState.move.x - inputState.move.startX;
        const vy = inputState.move.y - inputState.move.startY;
        const len = Math.hypot(vx,vy);
        if (len > inputState.dead){
          dx = vx/len; dy = vy/len;
        }
      }
      // æ­£è¦åŒ–
      if (dx!==0 && dy!==0){ dx *= 0.7071; dy *= 0.7071; }
      return {dx: dx*speed, dy: dy*speed, moving: (dx!==0 || dy!==0)};
    }

    // å®Œå…¨ã‚ªãƒ¼ãƒˆã‚¨ã‚¤ãƒ ï¼ˆæœ€ã‚‚è¿‘ã„æ•µã‚’ç‹™ã†ï¼‰
    function getAutoAimAngle(player){
      let target=null, best=Infinity;
      for(const e of gameState.enemies){
        const d=Math.hypot(e.x-player.x, e.y-player.y);
        if (d<best){ best=d; target=e; }
      }
      if (target) return Math.atan2(target.y-player.y, target.x-player.x);
      return null;
    }

    // ===== é›£æ˜“åº¦ãƒ‡ã‚£ãƒ¬ã‚¯ã‚¿ãƒ¼ï¼ˆ10åˆ†ã‚¯ãƒªã‚¢æƒ³å®šï¼‰ =====
    function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
    function lerp(a,b,t){ return a + (b-a)*clamp(t,0,1); }
    function getDifficulty(frames){
      const sec = frames/60, min=sec/60, t=clamp(min/10,0,1);
      const spawnInterval = Math.round(lerp(110, 50, t));   // 1.83s â†’ 0.83s
      const batchSize     = 1 + Math.floor(lerp(0, 6, t));  // 1 â†’ 7
      const maxEnemies    = Math.floor(lerp(30, 90, t));    // 30 â†’ 90
      const enemyHP  = Math.round(lerp(22, 100, t));
      const enemySpd = lerp(1.0, 2.2, t);
      const enemyDmg = Math.round(lerp(12, 22, t));
      const expValue = 2 + Math.floor(lerp(0, 3, t));       // 2 â†’ 5
      const baseFireRate = Math.round(lerp(800, 320, t));   // 0.8s â†’ 0.32s
      const baseDamage   = Math.round(lerp(22, 36, t));     // 22 â†’ 36
      return {sec,min,t,spawnInterval,batchSize,maxEnemies,enemyHP,enemySpd,enemyDmg,expValue,baseFireRate,baseDamage};
    }

    // ===== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ =====
    let gameState = {
      player:null, enemies:[], bullets:[], particles:[], items:[],
      gameTime:0, lastEnemySpawn:0, isPaused:false
    };

    // ===== æ­¦å™¨ã‚·ã‚¹ãƒ†ãƒ å®šæ•° =====
    const WeaponType = {
      SPEED: 'speed',    // é€Ÿå°„å‹
      SPREAD: 'spread',  // å¼¾å¹•å‹  
      LASER: 'laser'     // ãƒ¬ãƒ¼ã‚¶ãƒ¼å‹
    };

    // ===== ã‚¯ãƒ©ã‚¹ =====
    class Player{
      constructor(x,y){
        this.x=x; this.y=y;
        this.imageScale=0.8;                 // æŒ‡å®šã©ãŠã‚Š
        this.size=32*this.imageScale;        // ç”»åƒèª­è¾¼å¾Œã«å†è¨ˆç®—ï¼šå½“ãŸã‚Šåˆ¤å®šåŠå¾„
        this.speed=3;
        this.maxHp=100; this.hp=this.maxHp;
        this.level=1; this.exp=0; this.expMax=10; this.score=0;
        this.lastShot=0;
        this.fireRate=800;                   // åˆæœŸé…ã„ï¼ˆãƒ‡ã‚£ãƒ¬ã‚¯ã‚¿ãƒ¼ã§è‡ªç„¶çŸ­ç¸®ï¼‰
        this.damage=22;                      // åŒä¸Š
        this.invulnerable=0;
        this.orbRotation=0;
        this.isMoving=false;
        this.weapon = new WeaponSystem();    // æ­¦å™¨ã‚·ã‚¹ãƒ†ãƒ è¿½åŠ 
      }
      updateCollisionSizeFromImage(){
        if (characterImages.normal){
          this.size = (characterImages.normal.width * this.imageScale) / 2;
        }
      }
      update(){
        const diff = getDifficulty(gameState.gameTime);
        // è‡ªç„¶æˆé•·ï¼ˆãƒ¬ãƒ™ãƒ«ã¨ã¯åˆ¥ï¼‰
        this.fireRate = Math.min(this.fireRate, diff.baseFireRate);
        this.damage   = Math.max(this.damage, diff.baseDamage);

        const mv = getMoveVector(this.speed);
        this.isMoving = mv.moving;
        // ç«¯ã¾ã§è¡Œã‘ã‚‹ï¼ˆä¸­å¿ƒãŒåŠå¾„åˆ†ã ã‘å†…å´ï¼‰
        const r=this.size, W=canvas.clientWidth, H=canvas.clientHeight;
        this.x = Math.max(r, Math.min(W - r, this.x + mv.dx));
        this.y = Math.max(r, Math.min(H - r, this.y + mv.dy));

        if (this.isMoving) this.orbRotation += 0.1;
        if (this.invulnerable>0) this.invulnerable--;

        // æ­¦å™¨ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ã£ãŸæ”»æ’ƒ
        const currentFireRate = this.weapon.getFireRate(this.fireRate);
        if (Date.now() - this.lastShot > currentFireRate && gameState.enemies.length>0){
          this.shoot(); this.lastShot=Date.now();
        }
      }
      shoot(){
        const ang = getAutoAimAngle(this);
        if (ang==null) return;
        
        // æ­¦å™¨ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰å¼¾ã‚’ç”Ÿæˆ
        const bullets = this.weapon.getShootPattern(this.x, this.y, ang, this.damage);
        bullets.forEach(bullet => gameState.bullets.push(bullet));
      }
      takeDamage(d){ 
        if(this.invulnerable>0) return; 
        this.hp=Math.max(0,this.hp-d); 
        this.invulnerable=60; 
        for(let i=0;i<5;i++) gameState.particles.push(new Particle(this.x,this.y,'#f00')); 
      }
      gainExp(v){ 
        this.exp+=v; 
        this.score+=v*10; 
        if(this.exp>=this.expMax) this.levelUp(); 
      }
      levelUp(){ 
        this.level++; 
        this.exp-=this.expMax; 
        this.expMax=Math.floor(this.expMax*1.5); 
        document.getElementById('levelUpModal').style.display='block'; 
        gameState.isPaused=true; 
      }
      draw(){
        ctx.save();
        let damaged=false;
        if (this.invulnerable>0){ 
          if(Math.floor(this.invulnerable/10)%2===0) damaged=true; 
          ctx.globalAlpha=0.8; 
        }

        if (characterImages.normal && characterImages.orbs && characterImages.damaged){
          // ã‚ªãƒ¼ãƒ–å¸¸æ™‚è¡¨ç¤ºï¼ˆç§»å‹•ä¸­ã®ã¿å›è»¢è§’ãŒé€²ã‚€ï¼‰
          ctx.save(); 
          ctx.translate(this.x,this.y); 
          ctx.rotate(this.orbRotation);
          const os = characterImages.orbs.width * this.imageScale;
          ctx.drawImage(characterImages.orbs, -os/2, -os/2, os, os); 
          ctx.restore();

          const img = damaged ? characterImages.damaged : characterImages.normal;
          const isz = img.width * this.imageScale;
          ctx.drawImage(img, this.x - isz/2, this.y - isz/2, isz, isz);
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          ctx.fillStyle = damaged ? '#ffaa00' : '#ffcc00';
          ctx.beginPath(); 
          ctx.arc(this.x,this.y,this.size,0,Math.PI*2); 
          ctx.fill();
          ctx.strokeStyle='#000'; 
          ctx.lineWidth=2; 
          ctx.stroke();
          ctx.fillStyle='#000'; 
          ctx.font=`${this.size}px Arial`; 
          ctx.textAlign='center'; 
          ctx.textBaseline='middle';
          ctx.fillText(damaged?'ğŸ˜':'ğŸ˜Š', this.x, this.y);
        }
        
        // HPãƒãƒ¼
        const barW=40, barH=4, barY=this.y - (this.size+15);
        ctx.fillStyle='#f00'; 
        ctx.fillRect(this.x-barW/2,barY,barW,barH);
        ctx.fillStyle='#0f0'; 
        ctx.fillRect(this.x-barW/2,barY,barW*(this.hp/this.maxHp),barH);
        ctx.strokeStyle='#fff'; 
        ctx.lineWidth=1; 
        ctx.strokeRect(this.x-barW/2,barY,barW,barH);
        ctx.restore();

        // ã‚¿ãƒƒãƒUIã®å††ï¼ˆç°¡æ˜“ã‚¹ãƒ†ã‚£ãƒƒã‚¯è¡¨ç¤ºï¼‰
        drawTouchUI();
      }
    }

    class Enemy{
      constructor(x,y,diff){
        this.x=x; this.y=y;
        this.size=16;
        this.speed=diff.enemySpd;
        this.hp=diff.enemyHP; this.maxHp=this.hp;
        this.damage=diff.enemyDmg;
        this.expValue=diff.expValue;
        this.color=`hsl(${Math.random()*60+300},70%,50%)`;
      }
      update(){
        const dx=gameState.player.x-this.x, dy=gameState.player.y-this.y;
        const dist=Math.hypot(dx,dy);
        if (dist>0){ 
          this.x+=(dx/dist)*this.speed; 
          this.y+=(dy/dist)*this.speed; 
        }
        if (dist < this.size + gameState.player.size){ 
          gameState.player.takeDamage(this.damage); 
        }
      }
      takeDamage(d){
        this.hp -= d;
        for(let i=0;i<3;i++) gameState.particles.push(new Particle(this.x,this.y,this.color));
        if(this.hp<=0){ 
          gameState.items.push(new ExpItem(this.x,this.y,this.expValue)); 
          return true; 
        }
        return false;
      }
      draw(){
        ctx.fillStyle=this.color; 
        ctx.beginPath(); 
        ctx.arc(this.x,this.y,this.size,0,Math.PI*2); 
        ctx.fill();
        ctx.fillStyle='#fff'; 
        ctx.beginPath(); 
        ctx.arc(this.x-4,this.y-4,2,0,Math.PI*2); 
        ctx.arc(this.x+4,this.y-4,2,0,Math.PI*2); 
        ctx.fill();
        ctx.fillStyle='#000'; 
        ctx.beginPath(); 
        ctx.arc(this.x-4,this.y-4,1,0,Math.PI*2); 
        ctx.arc(this.x+4,this.y-4,1,0,Math.PI*2); 
        ctx.fill();
        
        if(this.hp<this.maxHp){
          const w=20,h=3; 
          ctx.fillStyle='#f00'; 
          ctx.fillRect(this.x-w/2,this.y-this.size-8,w,h);
          ctx.fillStyle='#0f0'; 
          ctx.fillRect(this.x-w/2,this.y-this.size-8,w*(this.hp/this.maxHp),h);
        }
      }
    }

    class Bullet{
      constructor(x,y,ang,damage,isPlayerBullet=false){
        this.x=x; this.y=y; 
        this.vx=Math.cos(ang)*8; 
        this.vy=Math.sin(ang)*8;
        this.damage=damage; 
        this.isPlayerBullet=isPlayerBullet; 
        this.life=120;
      }
      update(){
        this.x+=this.vx; 
        this.y+=this.vy; 
        this.life--;
        const W=canvas.clientWidth, H=canvas.clientHeight;
        if(this.x<0||this.x>W||this.y<0||this.y>H||this.life<=0) return true;
        
        if(this.isPlayerBullet){
          for(let i=gameState.enemies.length-1;i>=0;i--){
            const e=gameState.enemies[i];
            const d=Math.hypot(e.x-this.x,e.y-this.y);
            if(d<e.size){
              if(e.takeDamage(this.damage)) gameState.enemies.splice(i,1);
              return true;
            }
          }
        }
        return false;
      }
      draw(){
        ctx.fillStyle=this.isPlayerBullet?'#ff0':'#f00';
        ctx.beginPath(); 
        ctx.arc(this.x,this.y,3,0,Math.PI*2); 
        ctx.fill();
        ctx.fillStyle=this.isPlayerBullet?'rgba(255,255,0,.3)':'rgba(255,0,0,.3)';
        ctx.beginPath(); 
        ctx.arc(this.x-this.vx,this.y-this.vy,2,0,Math.PI*2); 
        ctx.fill();
      }
    }

    // ===== ãƒ¬ãƒ¼ã‚¶ãƒ¼å¼¾ã‚¯ãƒ©ã‚¹ =====
    class LaserBullet extends Bullet {
      constructor(x, y, angle, damage, isPlayerBullet, speed = 10, pierce = false, reflect = false) {
        super(x, y, angle, damage, isPlayerBullet);
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.pierce = pierce;
        this.reflect = reflect;
        this.hitTargets = new Set(); // è²«é€šæ™‚ã®é‡è¤‡ãƒ’ãƒƒãƒˆé˜²æ­¢
        this.life = 180; // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã¯é•·å¯¿å‘½
        this.reflectCount = 0;
        this.maxReflects = 3;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        
        const W = canvas.clientWidth, H = canvas.clientHeight;
        
        // åå°„å‡¦ç†
        if (this.reflect && this.reflectCount < this.maxReflects) {
          if (this.x <= 0 || this.x >= W) {
            this.vx *= -1;
            this.x = Math.max(0, Math.min(W, this.x));
            this.reflectCount++;
          }
          if (this.y <= 0 || this.y >= H) {
            this.vy *= -1;
            this.y = Math.max(0, Math.min(H, this.y));
            this.reflectCount++;
          }
        } else {
          // é€šå¸¸ã®å¢ƒç•Œãƒã‚§ãƒƒã‚¯
          if (this.x < 0 || this.x > W || this.y < 0 || this.y > H || this.life <= 0) {
            return true;
          }
        }

        // æ•µã¨ã®å½“ãŸã‚Šåˆ¤å®š
        if (this.isPlayerBullet) {
          for (let i = gameState.enemies.length - 1; i >= 0; i--) {
            const e = gameState.enemies[i];
            const d = Math.hypot(e.x - this.x, e.y - this.y);
            
            if (d < e.size && !this.hitTargets.has(e)) {
              if (this.pierce) {
                this.hitTargets.add(e);
              }
              
              if (e.takeDamage(this.damage)) {
                gameState.enemies.splice(i, 1);
              }
              
              if (!this.pierce) {
                return true; // è²«é€šã—ãªã„å ´åˆã¯æ¶ˆæ»…
              }
            }
          }
        }
        
        return false;
      }

      draw() {
        ctx.save();
        // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã‚‰ã—ã„æç”»
        const angle = Math.atan2(this.vy, this.vx);
        const length = Math.hypot(this.vx, this.vy) * 2;
        
        ctx.translate(this.x, this.y);
        ctx.rotate(angle);
        
        // ã‚³ã‚¢éƒ¨åˆ†ï¼ˆæ˜ã‚‹ã„ï¼‰
        ctx.fillStyle = this.isPlayerBullet ? '#ff00ff' : '#ff0000';
        ctx.fillRect(-length/2, -2, length, 4);
        
        // å¤–å´ï¼ˆè–„ã„ï¼‰
        ctx.fillStyle = this.isPlayerBullet ? 'rgba(255,0,255,0.3)' : 'rgba(255,0,0,0.3)';
        ctx.fillRect(-length/2, -4, length, 8);
        
        ctx.restore();
      }
    }

    // ===== æ­¦å™¨ã‚·ã‚¹ãƒ†ãƒ  =====
    class WeaponSystem {
      constructor() {
        this.type = WeaponType.SPEED; // åˆæœŸæ­¦å™¨
        this.level = 1;
        this.maxLevel = 5;
      }

      // æ­¦å™¨ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
      levelUp() {
        if (this.level < this.maxLevel) {
          this.level++;
          return true;
        }
        return false;
      }

      // æ­¦å™¨åˆ‡ã‚Šæ›¿ãˆï¼ˆãƒ¬ãƒ™ãƒ«å¼•ãç¶™ãï¼‰
      switchWeapon(newType) {
        this.type = newType;
        // ãƒ¬ãƒ™ãƒ«ã¯ç¶­æŒã•ã‚Œã‚‹
      }

      // å°„æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å–å¾—
      getShootPattern(x, y, angle, damage) {
        switch(this.type) {
          case WeaponType.SPEED:
            return this.getSpeedPattern(x, y, angle, damage);
          case WeaponType.SPREAD:
            return this.getSpreadPattern(x, y, angle, damage);
          case WeaponType.LASER:
            return this.getLaserPattern(x, y, angle, damage);
          default:
            return [];
        }
      }

      // é€Ÿå°„å‹ãƒ‘ã‚¿ãƒ¼ãƒ³
      getSpeedPattern(x, y, angle, damage) {
        const bullets = [];
        if (this.level >= 3) {
          // Lv3: 2é€£å°„
          const offset = 0.1;
          bullets.push(new Bullet(x, y, angle - offset, damage, true));
          bullets.push(new Bullet(x, y, angle + offset, damage, true));
        }
        if (this.level >= 5) {
          // Lv5: 3é€£å°„ï¼ˆä¸­å¤®è¿½åŠ ï¼‰
          bullets.push(new Bullet(x, y, angle, damage, true));
        }
        if (bullets.length === 0) {
          // Lv1-2: å˜ç™º
          bullets.push(new Bullet(x, y, angle, damage, true));
        }
        return bullets;
      }

      // å¼¾å¹•å‹ãƒ‘ã‚¿ãƒ¼ãƒ³  
      getSpreadPattern(x, y, angle, damage) {
        const bullets = [];
        if (this.level >= 5) {
          // Lv5: 7-9wayå¤§å¼¾å¹•
          const ways = 9;
          const spread = Math.PI / 3; // 60åº¦ç¯„å›²
          for (let i = 0; i < ways; i++) {
            const a = angle - spread/2 + (spread / (ways-1)) * i;
            bullets.push(new Bullet(x, y, a, damage * 0.8, true)); // å¨åŠ›å°‘ã—ä¸‹ã’ã‚‹
          }
        } else if (this.level >= 3) {
          // Lv3: æ‹¡æ•£ï¼‹ä¸­å¤®ç›´é€²å¼¾
          bullets.push(new Bullet(x, y, angle, damage, true)); // ä¸­å¤®
          const ways = 5;
          const spread = Math.PI / 4; // 45åº¦ç¯„å›²
          for (let i = 0; i < ways; i++) {
            const a = angle - spread/2 + (spread / (ways-1)) * i;
            bullets.push(new Bullet(x, y, a, damage * 0.7, true));
          }
        } else {
          // Lv1-2: 3way
          bullets.push(new Bullet(x, y, angle - 0.3, damage * 0.8, true));
          bullets.push(new Bullet(x, y, angle, damage, true));
          bullets.push(new Bullet(x, y, angle + 0.3, damage * 0.8, true));
        }
        return bullets;
      }

      // ãƒ¬ãƒ¼ã‚¶ãƒ¼å‹ãƒ‘ã‚¿ãƒ¼ãƒ³
      getLaserPattern(x, y, angle, damage) {
        const bullets = [];
        const speed = this.level >= 3 ? 12 : 10; // Lv3+ã§é«˜é€Ÿ
        const pierce = this.level >= 3; // Lv3+ã§è²«é€š
        const reflect = this.level >= 5; // Lv5ã§åå°„
        
        const bullet = new LaserBullet(x, y, angle, damage * 1.5, true, speed, pierce, reflect);
        bullets.push(bullet);
        return bullets;
      }

      // é€£å°„é€Ÿåº¦å–å¾—
      getFireRate(baseRate) {
        switch(this.type) {
          case WeaponType.SPEED:
            // é€Ÿå°„å‹ã¯é€£å°„é€Ÿåº¦æœ€å„ªå…ˆ
            return Math.max(100, baseRate - (this.level * 80));
          case WeaponType.SPREAD:
            // å¼¾å¹•å‹ã¯æ¨™æº–çš„ãªé€£å°„é€Ÿåº¦
            return Math.max(200, baseRate - (this.level * 40));
          case WeaponType.LASER:
            // ãƒ¬ãƒ¼ã‚¶ãƒ¼å‹ã¯ä½é€£å°„ã ãŒé«˜å¨åŠ›
            return Math.max(400, baseRate - (this.level * 20));
          default:
            return baseRate;
        }
      }

      // æ­¦å™¨åå–å¾—
      getWeaponName() {
        const names = {
          [WeaponType.SPEED]: 'é€Ÿå°„',
          [WeaponType.SPREAD]: 'å¼¾å¹•', 
          [WeaponType.LASER]: 'ãƒ¬ãƒ¼ã‚¶ãƒ¼'
        };
        return `${names[this.type]}Lv${this.level}`;
      }
    }

    class Particle{
      constructor(x,y,color){ 
        this.x=x; this.y=y; 
        this.vx=(Math.random()-0.5)*4; 
        this.vy=(Math.random()-0.5)*4; 
        this.color=color; 
        this.life=30; 
        this.maxLife=30; 
        this.size=Math.random()*3+1; 
      }
      update(){ 
        this.x+=this.vx; 
        this.y+=this.vy; 
        this.vx*=0.98; 
        this.vy*=0.98; 
        this.life--; 
        return this.life<=0; 
      }
      draw(){ 
        const a=this.life/this.maxLife; 
        ctx.save(); 
        ctx.globalAlpha=a; 
        ctx.fillStyle=this.color; 
        ctx.beginPath(); 
        ctx.arc(this.x,this.y,this.size,0,Math.PI*2); 
        ctx.fill(); 
        ctx.restore(); 
      }
    }
    
    class ExpItem{
      constructor(x,y,v){ 
        this.x=x; this.y=y; 
        this.value=v; 
        this.size=4; 
        this.bobOffset=Math.random()*Math.PI*2; 
      }
      update(){
        const dx=gameState.player.x-this.x, dy=gameState.player.y-this.y, dist=Math.hypot(dx,dy);
        if(dist<50){ 
          this.x+=(dx/dist)*3; 
          this.y+=(dy/dist)*3; 
        }
        if(dist < this.size + gameState.player.size){ 
          gameState.player.gainExp(this.value); 
          return true; 
        }
        return false;
      }
      draw(){
        const bob=Math.sin(Date.now()*0.005 + this.bobOffset)*2;
        ctx.fillStyle='#0f0'; 
        ctx.beginPath(); 
        ctx.arc(this.x,this.y+bob,this.size,0,Math.PI*2); 
        ctx.fill();
        ctx.strokeStyle='#fff'; 
        ctx.lineWidth=1; 
        ctx.stroke();
      }
    }

    // ã‚¿ãƒƒãƒUIï¼ˆå††ã‚’æãã ã‘ï¼‰
    function drawTouchUI(){
      if (inputState.move.active) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#00ffff';
        // å¤–å´ã®å††ï¼ˆã‚¿ãƒƒãƒé–‹å§‹ä½ç½®ï¼‰
        ctx.beginPath(); 
        ctx.arc(inputState.move.startX, inputState.move.startY, 40, 0, Math.PI*2); 
        ctx.stroke();
        // å†…å´ã®å††ï¼ˆç¾åœ¨ä½ç½®ï¼‰
        ctx.beginPath(); 
        ctx.arc(inputState.move.x, inputState.move.y, 20, 0, Math.PI*2); 
        ctx.stroke();
        // ç·šã§çµã¶
        ctx.beginPath();
        ctx.moveTo(inputState.move.startX, inputState.move.startY);
        ctx.lineTo(inputState.move.x, inputState.move.y);
        ctx.stroke();
        ctx.restore();
      }
    }

    // ===== ã‚¹ãƒãƒ¼ãƒ³ =====
    function spawnEnemy(){
      const diff = getDifficulty(gameState.gameTime);
      if (gameState.enemies.length >= diff.maxEnemies) return;
      const W=canvas.clientWidth, H=canvas.clientHeight;
      const side=Math.floor(Math.random()*4);
      let x,y;
      if(side===0){ x=Math.random()*W; y=-20; }
      else if(side===1){ x=W+20; y=Math.random()*H; }
      else if(side===2){ x=Math.random()*W; y=H+20; }
      else { x=-20; y=Math.random()*H; }
      gameState.enemies.push(new Enemy(x,y,diff));
    }

    // ===== ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ =====
    function selectUpgrade(type){
      const p=gameState.player;
      if (type==='weapon') {
        // æ­¦å™¨ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
        p.weapon.levelUp();
      } else if (type==='weapon_change') {
        // æ­¦å™¨ã‚¿ã‚¤ãƒ—å¤‰æ›´ï¼ˆã‚µã‚¤ã‚¯ãƒ«ï¼‰
        const types = [WeaponType.SPEED, WeaponType.SPREAD, WeaponType.LASER];
        const currentIndex = types.indexOf(p.weapon.type);
        const nextIndex = (currentIndex + 1) % types.length;
        p.weapon.switchWeapon(types[nextIndex]);
      } else if (type==='speed') {
        p.speed+=0.5;
      } else if (type==='health') { 
        p.maxHp+=20; 
        p.hp=Math.min(p.hp+20,p.maxHp); 
      }
      document.getElementById('levelUpModal').style.display='none';
      gameState.isPaused=false;
    }
    window.selectUpgrade = selectUpgrade;

    // ===== UI =====
    function updateUI(){
      const p=gameState.player;
      document.getElementById('hp').textContent=p.hp; 
      document.getElementById('level').textContent=p.level; 
      document.getElementById('exp').textContent=p.exp;
      document.getElementById('expMax').textContent=p.expMax; 
      document.getElementById('score').textContent=p.score;
      document.getElementById('time').textContent=Math.floor(gameState.gameTime/60);
      document.getElementById('weapon').textContent=p.weapon.getWeaponName();
    }

    // ===== ãƒ«ãƒ¼ãƒ— =====
    function gameLoop(){
      if (!gameState.isPaused){
        gameState.gameTime++;
        const diff = getDifficulty(gameState.gameTime);
        const since = gameState.gameTime - gameState.lastEnemySpawn;
        if (since > diff.spawnInterval){
          for(let i=0;i<diff.batchSize;i++) spawnEnemy();
          gameState.lastEnemySpawn = gameState.gameTime;
        }
        if (gameState.player.hp>0) gameState.player.update();
        gameState.enemies.forEach(e=>e.update());
        gameState.bullets   = gameState.bullets.filter(b=>!b.update());
        gameState.particles = gameState.particles.filter(p=>!p.update());
        gameState.items     = gameState.items.filter(it=>!it.update());
        updateUI();
      }

      // èƒŒæ™¯
      const W=canvas.clientWidth, H=canvas.clientHeight;
      ctx.fillStyle='#16213e'; 
      ctx.fillRect(0,0,W,H);
      ctx.strokeStyle='rgba(255,255,255,0.05)'; 
      ctx.lineWidth=1;
      for(let x=0;x<W;x+=50){ 
        ctx.beginPath(); 
        ctx.moveTo(x,0); 
        ctx.lineTo(x,H); 
        ctx.stroke(); 
      }
      for(let y=0;y<H;y+=50){ 
        ctx.beginPath(); 
        ctx.moveTo(0,y); 
        ctx.lineTo(W,y); 
        ctx.stroke(); 
      }

      gameState.items.forEach(it=>it.draw());
      gameState.particles.forEach(p=>p.draw());
      gameState.enemies.forEach(e=>e.draw());
      gameState.bullets.forEach(b=>b.draw());

      if (gameState.player.hp>0) gameState.player.draw();
      
      if (gameState.player.hp<=0){
        ctx.fillStyle='rgba(0,0,0,.7)'; 
        ctx.fillRect(0,0,W,H);
        ctx.fillStyle='#fff'; 
        ctx.font='48px monospace'; 
        ctx.textAlign='center';
        ctx.fillText('GAME OVER', W/2, H/2);
        ctx.font='24px monospace';
        ctx.fillText(`Final Score: ${gameState.player.score}`, W/2, H/2+50);
        ctx.fillText('Press R to Restart', W/2, H/2+100);
      }

      requestAnimationFrame(gameLoop);
    }

    // ===== åˆæœŸåŒ– =====
    async function initGame(){
      await loadCharacterImages();
      resizeCanvas();
      gameState.player = new Player(canvas.clientWidth/2, canvas.clientHeight/2);
      gameState.player.updateCollisionSizeFromImage();
      gameState.enemies=[]; gameState.bullets=[]; gameState.particles=[]; gameState.items=[];
      gameState.gameTime=0; gameState.lastEnemySpawn=0; gameState.isPaused=false;
      document.getElementById('levelUpModal').style.display='none';
    }

    initGame().then(()=>{ gameLoop(); });
  </script>
</body>
</html>
