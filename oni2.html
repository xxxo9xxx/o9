<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>鬼ごっこゲーム（桃太郎 vs 鬼｜スマホ対応版）</title>
  <style>
    :root { 
      --bg:#0b0e1a; 
      --goal:#5bff85; 
      --enemy:#ff6b6b; 
      --ob:#4a4a6a;
      --player1:#4aa8ff;
      --player2:#ff7070;
    }
    * { box-sizing: border-box; }
    body { 
      margin: 0; 
      background: var(--bg); 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      font-family: system-ui, -apple-system, 'Noto Sans JP', sans-serif;
      overflow: hidden;
      touch-action: none;
    }
    h1 { 
      color: white; 
      margin: 10px 0 6px; 
      font: 600 clamp(16px, 4vw, 22px)/1.2 system-ui, -apple-system, 'Noto Sans JP', sans-serif; 
      text-align: center;
    }
    .hint { 
      color:#cfd3ffcc; 
      font-size: clamp(10px, 2.5vw, 14px); 
      margin-bottom: 6px; 
      text-align: center;
      padding: 0 10px;
    }
    canvas { 
      background: #0f1220; 
      border: 2px solid #ffffff22; 
      margin-top: 6px; 
      border-radius: 8px; 
      box-shadow: 0 10px 40px rgba(0,0,0,.4);
      max-width: 100vw;
      max-height: 70vh;
    }
    #menu { 
      margin:20px; 
      text-align: center;
    }
    #menu p { 
      color: white; 
      font-size: clamp(14px, 3vw, 18px);
    }
    button { 
      margin:8px; 
      padding: clamp(8px, 2vw, 12px) clamp(16px, 4vw, 24px); 
      font-weight:700; 
      border:none; 
      border-radius:8px; 
      cursor:pointer;
      font-size: clamp(12px, 3vw, 16px);
      background: linear-gradient(45deg, #4a90e2, #5ba7f7);
      color: white;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover, button:active {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(74, 144, 226, 0.4);
    }
    .controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      z-index: 1000;
    }
    .joystick-container {
      position: relative;
      width: 100px;
      height: 100px;
      background: rgba(255,255,255,0.1);
      border-radius: 50%;
      margin: 0 20px;
      touch-action: none;
      border: 2px solid rgba(255,255,255,0.3);
    }
    .joystick {
      position: absolute;
      width: 40px;
      height: 40px;
      background: var(--player1);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: background-color 0.2s;
      border: 3px solid rgba(255,255,255,0.8);
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    .joystick.player2 {
      background: var(--player2);
    }
    .control-row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 40px;
    }
    .reset-btn-mobile {
      background: rgba(255,255,255,0.1);
      color: white;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
    }
    .game-info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: clamp(12px, 2.5vw, 16px);
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 8px 12px;
      border-radius: 6px;
    }
    .lives-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      font-size: clamp(12px, 2.5vw, 16px);
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 8px 12px;
      border-radius: 6px;
    }
    @media (max-width: 768px) {
      canvas {
        width: 100vw !important;
        height: 60vh !important;
        margin: 0;
        border-radius: 0;
      }
      .controls {
        display: block;
      }
      .hint {
        font-size: 12px;
        margin: 10px;
      }
    }
    .tutorial {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      z-index: 2000;
      max-width: 90vw;
      border: 2px solid #4a90e2;
    }
    .tutorial h3 {
      color: var(--goal);
      margin-top: 0;
    }
    .tutorial button {
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>🍑 鬼ごっこゲーム（桃太郎 vs 鬼）👹</h1>
  
  <div id="menu">
    <p>プレイヤー数を選択:</p>
    <button onclick="startGame(1)">👤 1人プレイ</button>
    <button onclick="startGame(2)">👥 2人プレイ</button>
    <button onclick="showTutorial()">❓ 遊び方</button>
  </div>
  
  <div class="hint" id="hint" style="display:none;">
    <div class="desktop-hint">PC: WASD / 矢印キー | R: リスタート</div>
    <div class="mobile-hint">📱 スマホ: 下のスティックで移動</div>
    <br><strong>🎯 全員でゴールしよう！</strong>
  </div>
  
  <div style="position: relative;">
    <canvas id="game" width="900" height="550" style="display:none;"></canvas>
    
    <div class="game-info" id="gameInfo" style="display:none;">
      <div>ステージ: <span id="stageNum">1</span> / 10</div>
      <div>鬼の数: <span id="enemyNum">3</span></div>
    </div>
    
    <div class="lives-indicator" id="livesInfo" style="display:none;"></div>
  </div>

  <button id="resetBtn" style="display:none;">🔄 リセット</button>

  <!-- スマホ用コントロール -->
  <div class="controls" id="mobileControls">
    <div class="control-row">
      <div class="joystick-container" id="joystick1" data-player="0">
        <div class="joystick"></div>
      </div>
      
      <div class="reset-btn-mobile" onclick="reset()">🔄</div>
      
      <div class="joystick-container" id="joystick2" data-player="1" style="display:none;">
        <div class="joystick player2"></div>
      </div>
    </div>
  </div>

  <!-- チュートリアル -->
  <div id="tutorial" class="tutorial" style="display:none;">
    <h3>🎮 遊び方</h3>
    <p><strong>目標:</strong> 鬼から逃げて緑のゴールエリアに入ろう！</p>
    <p><strong>ルール:</strong></p>
    <ul style="text-align: left; display: inline-block;">
      <li>🍑 桃太郎（青/赤）を操作</li>
      <li>👹 鬼に捕まらないよう注意</li>
      <li>🧱 灰色の障害物を利用して隠れよう</li>
      <li>💚 全員がゴールしないとクリアできない</li>
      <li>📈 ステージが進むと鬼が増える</li>
    </ul>
    <p><strong>操作:</strong></p>
    <p>PC: WASD / 矢印キー<br>スマホ: 画面下のスティック</p>
    <button onclick="closeTutorial()">始める！</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = canvas.width, H = canvas.height;

    const resetBtn = document.getElementById('resetBtn');
    resetBtn.addEventListener('click', reset);

    let playerCount = 1;
    let players = [];
    let isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    const goal = { x: 0, y: 0, w: 50, h: 120 };

    let stage = 1;
    let enemyCount = 3;
    const MAX_STAGE = 10;
    const enemies = [];
    const obstacles = [];
    let running = true;
    let gameStarted = false;

    // レスポンシブ対応
    function resizeCanvas() {
      if (isMobile) {
        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        canvas.width = vw;
        canvas.height = vh * 0.6;
      }
      W = canvas.width;
      H = canvas.height;
      goal.x = W - 70;
      goal.y = H / 2 - 60;
    }

    // タッチコントロール
    class TouchController {
      constructor(element, playerIndex) {
        this.element = element;
        this.playerIndex = playerIndex;
        this.joystick = element.querySelector('.joystick');
        this.isActive = false;
        this.centerX = 50;
        this.centerY = 50;
        this.currentX = 50;
        this.currentY = 50;
        
        this.setupEvents();
      }

      setupEvents() {
        this.element.addEventListener('touchstart', this.onStart.bind(this), {passive: false});
        this.element.addEventListener('touchmove', this.onMove.bind(this), {passive: false});
        this.element.addEventListener('touchend', this.onEnd.bind(this), {passive: false});
        
        // マウスイベント（デスクトップでのテスト用）
        this.element.addEventListener('mousedown', this.onStart.bind(this));
        this.element.addEventListener('mousemove', this.onMove.bind(this));
        this.element.addEventListener('mouseup', this.onEnd.bind(this));
        this.element.addEventListener('mouseleave', this.onEnd.bind(this));
      }

      onStart(e) {
        e.preventDefault();
        this.isActive = true;
        this.updatePosition(e);
      }

      onMove(e) {
        if (!this.isActive) return;
        e.preventDefault();
        this.updatePosition(e);
      }

      onEnd(e) {
        e.preventDefault();
        this.isActive = false;
        this.currentX = this.centerX;
        this.currentY = this.centerY;
        this.updateJoystick();
        this.updatePlayerInput();
      }

      updatePosition(e) {
        const rect = this.element.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        
        const dx = x - this.centerX;
        const dy = y - this.centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const maxDistance = 30;
        
        if (distance <= maxDistance) {
          this.currentX = x;
          this.currentY = y;
        } else {
          const angle = Math.atan2(dy, dx);
          this.currentX = this.centerX + Math.cos(angle) * maxDistance;
          this.currentY = this.centerY + Math.sin(angle) * maxDistance;
        }
        
        this.updateJoystick();
        this.updatePlayerInput();
      }

      updateJoystick() {
        this.joystick.style.left = this.currentX + 'px';
        this.joystick.style.top = this.currentY + 'px';
        this.joystick.style.transform = 'translate(-50%, -50%)';
      }

      updatePlayerInput() {
        if (!players[this.playerIndex]) return;
        
        const dx = this.currentX - this.centerX;
        const dy = this.currentY - this.centerY;
        const threshold = 10;
        
        const player = players[this.playerIndex];
        player.inputs.left = dx < -threshold;
        player.inputs.right = dx > threshold;
        player.inputs.up = dy < -threshold;
        player.inputs.down = dy > threshold;
      }
    }

    let touchControllers = [];

    function setupMobileControls() {
      touchControllers = [];
      const joystick1 = document.getElementById('joystick1');
      const joystick2 = document.getElementById('joystick2');
      
      if (joystick1) touchControllers.push(new TouchController(joystick1, 0));
      if (joystick2 && playerCount >= 2) {
        joystick2.style.display = 'block';
        touchControllers.push(new TouchController(joystick2, 1));
      } else if (joystick2) {
        joystick2.style.display = 'none';
      }
    }

    function isOnObstacle(x, y, r) {
      for (const o of obstacles) {
        if (x > o.x - r && x < o.x + o.w + r && y > o.y - r && y < o.y + o.h + r) {
          return true;
        }
      }
      return false;
    }

    function spawnEnemies() {
      enemies.length = 0;
      for (let i = 0; i < enemyCount; i++) {
        let ex, ey, attempts = 0;
        do {
          ex = W / 2 + (Math.random() * 200 - 100);
          ey = H / 2 + (Math.random() * 200 - 100);
          attempts++;
        } while (isOnObstacle(ex, ey, 12) && attempts < 50);
        
        enemies.push({
          x: ex,
          y: ey,
          r: 12,
          vx: (Math.random() * 2 - 1) * 120,
          vy: (Math.random() * 2 - 1) * 120,
          targetPlayer: 0,
          changeTargetTimer: Math.random() * 3,
          stunTime: 0
        });
      }
    }

    function spawnObstacles(n = Math.min(8 + Math.floor(stage / 2), 12)) {
      obstacles.length = 0;
      for (let i = 0; i < n; i++) {
        const w = 60 + Math.random() * 100;
        const h = 30 + Math.random() * 60;
        const x = 60 + Math.random() * (W - 120 - w);
        const y = 60 + Math.random() * (H - 120 - h);
        
        const nearStart = (x < 160 && Math.abs(y - H / 2) < 140);
        const overlapGoal = !(x > goal.x + goal.w + 20 || x + w < goal.x - 20 || y > goal.y + goal.h + 20 || y + h < goal.y - 20);
        
        if (nearStart || overlapGoal) {
          i--;
          continue;
        }
        
        obstacles.push({ x, y, w, h });
      }
    }

    // キーボード入力
    addEventListener('keydown', e => {
      players.forEach(p => {
        const k = p.keys[e.key];
        if (k) p.inputs[k] = true;
      });
      if (e.key === 'r' || e.key === 'R') reset();
    });
    
    addEventListener('keyup', e => {
      players.forEach(p => {
        const k = p.keys[e.key];
        if (k) p.inputs[k] = false;
      });
    });

    function createPlayers() {
      players = [];
      players.push({
        x: 50,
        y: H / 2 - 30,
        r: 16,
        speed: 200,
        vx: 0,
        vy: 0,
        alive: true,
        inGoal: false,
        name: "桃太郎",
        color: '#4aa8ff',
        inputs: { up: false, down: false, left: false, right: false },
        keys: { w: 'up', s: 'down', a: 'left', d: 'right' }
      });
      
      if (playerCount >= 2) {
        players.push({
          x: 50,
          y: H / 2 + 30,
          r: 16,
          speed: 200,
          vx: 0,
          vy: 0,
          alive: true,
          inGoal: false,
          name: "桃太郎2",
          color: '#ff7070',
          inputs: { up: false, down: false, left: false, right: false },
          keys: { ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right' }
        });
      }
    }

    function reset() {
      resizeCanvas();
      createPlayers();
      spawnObstacles();
      spawnEnemies();
      running = true;
      updateUI();
    }

    function startGame(count) {
      playerCount = count;
      document.getElementById('menu').style.display = 'none';
      document.getElementById('hint').style.display = 'block';
      canvas.style.display = 'block';
      resetBtn.style.display = 'inline-block';
      document.getElementById('gameInfo').style.display = 'block';
      document.getElementById('livesInfo').style.display = 'block';
      
      if (isMobile) {
        document.getElementById('mobileControls').style.display = 'block';
      }
      
      gameStarted = true;
      setupMobileControls();
      reset();
    }

    function nextStage() {
      if (stage < MAX_STAGE) {
        stage++;
        enemyCount = Math.min(3 + stage, 8);
        // 効果音を鳴らす（実装可能な場合）
        reset();
      } else {
        running = false;
      }
    }

    function updateUI() {
      document.getElementById('stageNum').textContent = stage;
      document.getElementById('enemyNum').textContent = enemyCount;
      
      const alivePlayers = players.filter(p => p.alive);
      const livesText = players.map(p => `${p.name}: ${p.alive ? '💖' : '💔'}`).join(' | ');
      document.getElementById('livesInfo').innerHTML = livesText;
    }

    function circleRectCollision(cx, cy, cr, o) {
      const nx = Math.max(o.x, Math.min(cx, o.x + o.w));
      const ny = Math.max(o.y, Math.min(cy, o.y + o.h));
      const dx = cx - nx, dy = cy - ny;
      return dx * dx + dy * dy < cr * cr;
    }

    function update(dt) {
      if (!running || !gameStarted) return;

      // プレイヤー更新
      for (const p of players) {
        if (!p.alive) continue;
        
        const ax = (p.inputs.right ? 1 : 0) - (p.inputs.left ? 1 : 0);
        const ay = (p.inputs.down ? 1 : 0) - (p.inputs.up ? 1 : 0);
        
        const nx = p.x + ax * p.speed * dt;
        const ny = p.y + ay * p.speed * dt;
        
        let blocked = false;
        for (const o of obstacles) {
          if (circleRectCollision(nx, ny, p.r, o)) {
            blocked = true;
            break;
          }
        }
        
        if (!blocked) {
          p.vx = ax * p.speed;
          p.vy = ay * p.speed;
          p.x = nx;
          p.y = ny;
        } else {
          p.vx = 0;
          p.vy = 0;
        }
        
        // 画面端の制限
        if (p.x < p.r) p.x = p.r;
        if (p.y < p.r) p.y = p.r;
        if (p.x > W - p.r) p.x = W - p.r;
        if (p.y > H - p.r) p.y = H - p.r;
        
        // ゴール判定
        p.inGoal = (p.x > goal.x && p.x < goal.x + goal.w && p.y > goal.y && p.y < goal.y + goal.h);
      }

      // ゴール条件チェック
      const alive = players.filter(p => p.alive);
      if (alive.length > 0 && alive.every(p => p.inGoal)) {
        running = false;
        setTimeout(nextStage, 1500);
      }

      // 敵の更新
      for (const e of enemies) {
        if (e.stunTime > 0) {
          e.stunTime -= dt;
          continue;
        }

        e.changeTargetTimer -= dt;
        
        let targets = players.filter(pl => pl.alive && !pl.inGoal);
        if (targets.length === 0) {
          targets = players.filter(pl => pl.alive);
        }
        
        if (targets.length === 0) {
          running = false;
          return;
        }

        // ターゲット選択
        if (e.changeTargetTimer <= 0 || !targets[e.targetPlayer]) {
          e.targetPlayer = Math.floor(Math.random() * targets.length);
          e.changeTargetTimer = 2 + Math.random() * 3;
        }

        const t = targets[e.targetPlayer] || targets[0];
        const dx = t.x - e.x, dy = t.y - e.y;
        const d = Math.hypot(dx, dy) || 1;
        
        const ACC = 180 + stage * 10;
        const MAX = 250 + stage * 15;
        
        e.vx += (dx / d) * ACC * dt;
        e.vy += (dy / d) * ACC * dt;
        
        const v = Math.hypot(e.vx, e.vy);
        if (v > MAX) {
          e.vx = e.vx / v * MAX;
          e.vy = e.vy / v * MAX;
        }
        
        const nex = e.x + e.vx * dt;
        const ney = e.y + e.vy * dt;
        
        let blocked = false;
        for (const o of obstacles) {
          if (circleRectCollision(nex, ney, e.r, o)) {
            blocked = true;
            break;
          }
        }
        
        if (!blocked) {
          e.x = nex;
          e.y = ney;
        } else {
          e.vx *= -0.5;
          e.vy *= -0.5;
          e.stunTime = 0.5;
        }
        
        // 画面端での反射
        if (e.x < e.r) { e.x = e.r; e.vx *= -0.7; }
        if (e.y < e.r) { e.y = e.r; e.vy *= -0.7; }
        if (e.x > W - e.r) { e.x = W - e.r; e.vx *= -0.7; }
        if (e.y > H - e.r) { e.y = H - e.r; e.vy *= -0.7; }
        
        // プレイヤーとの衝突
        for (const p of players) {
          if (!p.alive) continue;
          const hit = Math.hypot(p.x - e.x, p.y - e.y) < p.r + e.r;
          if (hit) {
            p.alive = false;
            p.inGoal = false;
          }
        }
      }
      
      updateUI();
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);
      
      // グリッド背景
      ctx.save();
      ctx.strokeStyle = '#1a2146';
      ctx.globalAlpha = 0.3;
      ctx.lineWidth = 1;
      for (let x = 0; x < W; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for (let y = 0; y < H; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }
      ctx.restore();

      // ゴールエリア
      ctx.fillStyle = '#5bff85';
      ctx.fillRect(goal.x, goal.y, goal.w, goal.h);
      ctx.fillStyle = '#ffffff66';
      ctx.fillRect(15, H / 2 - 60, 8, 120);

      // 障害物
      ctx.fillStyle = '#4a4a6a';
      obstacles.forEach(o => {
        ctx.fillRect(o.x, o.y, o.w, o.h);
        // 障害物に影を追加
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(o.x + 2, o.y + 2, o.w, o.h);
        ctx.fillStyle = '#4a4a6a';
      });

      // プレイヤー
      players.forEach((p, i) => {
        ctx.save();
        if (!p.alive) {
          ctx.globalAlpha = 0.4;
        } else if (p.inGoal) {
          ctx.globalAlpha = 0.8;
        }
        
        // プレイヤー本体
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fill();
        
        // プレイヤーの顔（鉢巻き）
        ctx.strokeStyle = '#ff4444';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(p.x - p.r / 1.2, p.y - 2);
        ctx.lineTo(p.x + p.r / 1.2, p.y - 2);
        ctx.stroke();
        
        // プレイヤー番号
        ctx.fillStyle = 'white';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(i + 1, p.x, p.y + 4);
        
        // 移動方向の矢印
        if (p.alive && (Math.abs(p.vx) > 10 || Math.abs(p.vy) > 10)) {
          const angle = Math.atan2(p.vy, p.vx);
          ctx.strokeStyle = p.color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.x + Math.cos(angle) * (p.r + 5), p.y + Math.sin(angle) * (p.r + 5));
          ctx.lineTo(p.x + Math.cos(angle) * (p.r + 15), p.y + Math.sin(angle) * (p.r + 15));
          ctx.stroke();
        }
        
        ctx.restore();
      });

      // 敵（鬼）
      enemies.forEach(e => {
        ctx.save();
        
        if (e.stunTime > 0) {
          ctx.globalAlpha = 0.6;
        }
        
        // 鬼の本体
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
        ctx.fill();
        
        // 鬼のツノ
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(e.x - 6, e.y - e.r);
        ctx.lineTo(e.x - 12, e.y - e.r - 12);
        ctx.lineTo(e.x - 2, e.y - e.r - 3);
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(e.x + 6, e.y - e.r);
        ctx.lineTo(e.x + 12, e.y - e.r - 12);
        ctx.lineTo(e.x + 2, e.y - e.r - 3);
        ctx.fill();
        
        // 鬼の目
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(e.x - 4, e.y - 2, 2, 0, Math.PI * 2);
        ctx.arc(e.x + 4, e.y - 2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // 移動方向の表示
        if (e.stunTime <= 0) {
          const speed = Math.hypot(e.vx, e.vy);
          if (speed > 50) {
            const angle = Math.atan2(e.vy, e.vx);
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(e.x + Math.cos(angle) * (e.r + 3), e.y + Math.sin(angle) * (e.r + 3));
            ctx.lineTo(e.x + Math.cos(angle) * (e.r + 12), e.y + Math.sin(angle) * (e.r + 12));
            ctx.stroke();
            ctx.setLineDash([]);
          }
        }
        
        ctx.restore();
      });

      // ゲーム状態の表示
      if (!running && gameStarted) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, W, H);
        
        ctx.fillStyle = 'white';
        ctx.font = `bold ${Math.min(W * 0.08, 48)}px sans-serif`;
        ctx.textAlign = 'center';
        
        const allDead = players.every(p => !p.alive);
        const allStagesCleared = stage > MAX_STAGE;
        
        if (allDead) {
          ctx.fillStyle = '#ff6b6b';
          ctx.fillText('GAME OVER', W / 2, H / 2 - 20);
          ctx.fillStyle = 'white';
          ctx.font = `${Math.min(W * 0.04, 18)}px sans-serif`;
          ctx.fillText('鬼に捕まってしまった...', W / 2, H / 2 + 20);
        } else if (allStagesCleared) {
          ctx.fillStyle = '#5bff85';
          ctx.fillText('🎉 ALL CLEAR! 🎉', W / 2, H / 2 - 20);
          ctx.fillStyle = 'white';
          ctx.font = `${Math.min(W * 0.04, 18)}px sans-serif`;
          ctx.fillText('全ステージクリア！おめでとう！', W / 2, H / 2 + 20);
        } else {
          ctx.fillStyle = '#5bff85';
          ctx.fillText('STAGE CLEAR!', W / 2, H / 2 - 20);
          ctx.fillStyle = 'white';
          ctx.font = `${Math.min(W * 0.04, 18)}px sans-serif`;
          ctx.fillText(`ステージ ${stage} へ進行中...`, W / 2, H / 2 + 20);
        }
        
        ctx.font = `${Math.min(W * 0.03, 16)}px sans-serif`;
        ctx.fillText('Rキーまたはリセットボタンでリスタート', W / 2, H / 2 + 60);
      }

      // パーティクル効果（ゴール時）
      const inGoalPlayers = players.filter(p => p.alive && p.inGoal);
      if (inGoalPlayers.length > 0) {
        ctx.save();
        ctx.globalAlpha = 0.7;
        for (let i = 0; i < 20; i++) {
          const x = goal.x + Math.random() * goal.w;
          const y = goal.y + Math.random() * goal.h;
          const size = Math.random() * 3 + 1;
          
          ctx.fillStyle = `hsl(${120 + Math.random() * 60}, 70%, 60%)`;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }
    }

    function showTutorial() {
      document.getElementById('tutorial').style.display = 'block';
    }

    function closeTutorial() {
      document.getElementById('tutorial').style.display = 'none';
    }

    // ゲームループ
    let lastTime = 0;
    function gameLoop(currentTime) {
      requestAnimationFrame(gameLoop);
      const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.033);
      lastTime = currentTime;
      
      update(deltaTime);
      draw();
    }

    // 初期化
    window.addEventListener('resize', () => {
      if (gameStarted) {
        resizeCanvas();
      }
    });

    // ページ読み込み時の初期化
    document.addEventListener('DOMContentLoaded', () => {
      resizeCanvas();
      
      // モバイルデバイスの判定
      if (isMobile) {
        document.querySelector('.desktop-hint').style.display = 'none';
        document.querySelector('.mobile-hint').style.display = 'block';
      } else {
        document.querySelector('.desktop-hint').style.display = 'block';
        document.querySelector('.mobile-hint').style.display = 'none';
      }
    });

    // ゲーム開始
    requestAnimationFrame(gameLoop);

    // PWA対応のための基本設定
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        // サービスワーカーの登録は実際のPWA化時に追加
      });
    }

    // 画面の向き変更に対応
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        if (gameStarted) {
          resizeCanvas();
          reset();
        }
      }, 100);
    });

    // フルスクリーン対応
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen?.();
      } else {
        document.exitFullscreen?.();
      }
    }

    // タッチでのスクロール防止
    document.addEventListener('touchmove', (e) => {
      if (gameStarted) {
        e.preventDefault();
      }
    }, { passive: false });

  </script>
</body>
</html>